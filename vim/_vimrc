"*******************************************************************************
"*******************************************************************************
"**                       |    | --- |\  /| .--. .--.                         **
"**                       |    |  |  | \/ | |__' |                            **
"**                        \  /   |  |    | | \  |                            **
"**                       o \/   --- |    | |  \ `--'                         **
"**                                                                           **
"**                     Macros & Miscellaneous Settings                       **
"*******************************************************************************
"*******************************************************************************
set encoding=utf-8 fileencoding=utf-8 fileencodings=utf-8

filetype plugin indent on
syntax on

let mapleader=","

"let g:vim_markdown_folding_level=2
"let g:vim_markdown_new_list_item_indent=0
let g:vim_markdown_folding_style_pythonic=1
let NERDTreeIgnore=['apple.*png', 'favicon*']

set splitright

au BufWinEnter *.htm*,*.js[(on)]* silent loadview

"-------------------------------------------------------------------------------
" Pathogen settings
"-------------------------------------------------------------------------------
execute pathogen#infect()
execute pathogen#helptags()

let g:vim_json_syntax_conceal=0
let g:mustache_abbreviations=1

let g:NERDTreeShowGitStatus=0
let g:NERDTreeShowSvnStatus=1
let g:NERDTreeUpdateOnWrite=0

" open NERDTree when vim starts up with no file
autocmd StdinReadPre * let s:std_in=1
"autocmd VimEnter * if argc() == 0 && !exists("s:std_in") | NERDTree | norm l | endif
autocmd VimEnter * if argc() == 0 && !exists("s:std_in") | NERDTree | endif
au FileType nerdtree hi CursorLine ctermbg=yellow ctermfg=black
map <C-n> :NERDTreeToggle<CR>

" close vim if only window left open is NERDTree
autocmd BufEnter * if (winnr("$") == 1 && exists("b:NERDTreeType") && b:NERDTreeType == "primary") | q | endif

"----------------
" NETRW
"----------------
"let g:netrw_liststyle=3          " tree view
"let g:netrw_list_hide='.*\.sw.$,Sync.*\.dat' " hide these files
"let g:netrw_altv=1               " right split (netrw appears on left)
"let g:netrw_winsize=85           " 85% width on new windows
"let g:netrw_browse_split=4       " open previous window

au BufEnter flashlog.txt set syntax=flashlog

" Flex property files. Setup the Align script
au BufEnter *.properties,*.json let AlignCtrl=Align#AlignCtrl("l:")

au BufEnter file.*.json setlocal filetype=csv

fun! AlignSkipString(lineno,indx)
   let synId   = synID(a:lineno,a:indx+1,1)
   let synName = synIDattr(synId,"name")
   let ret = (synName == "javaScriptString") ? 1 : 0
   return ret
endfun
au BufEnter *.js let g:AlignSkip=function("AlignSkipString")
" search for a function of the same name as word under cursor
au BufEnter *.js nmap <F3> :call search(expand("<cword>").':\s*function')<CR>

" This is for ProCease (AHK) artifacts files
au BufEnter artifacts.txt set formatoptions=croql cindent comments=n:; filetype=txt tabstop=4

au BufEnter */itsalltext/*.txt set textwidth=0 wrap
au BufEnter */sa/redesign/* set textwidth=125 path+=c:/sa/redesign
au BufEnter *.md set textwidth=125 formatoptions-=c

" ??
highlight Pmenu ctermbg=Gray guibg=Gray
highlight PmenuSel guibg=DarkBlue ctermbg=DarkBlue guifg=Yellow ctermfg=Yellow

"-------------------------------------------------------------------------------
" Auto Correct Common Misspellings:
"-------------------------------------------------------------------------------
:cab wq1 wq!
:cab q1 q!

"-------------------------------------------------------------------------------
" Plugin Settings:
"-------------------------------------------------------------------------------
"let Tlist_Ctags_Cmd="$BIN/ctags.exe"
"vnoremap <c-a> :Inc<CR> 

"-------------------------------------------------------------------------------
" FUNCTION KEYS:
"-------------------------------------------------------------------------------
noremap <F4> :echo synIDattr(synID(line("."), col("."), 1), "name")<CR>
noremap <F5> :call ToggleOption('hlsearch')<CR>
noremap <F7> :bNext<CR>     " Previous buffer
noremap <F8> :bnext<CR>     " Next buffer

"-------------------------------------------------------------------------------
" QUICK FILE LIST:
" Show file list of commonly used files from quick list file
"-------------------------------------------------------------------------------
ru CQuickFileList.src
au BufEnter,BufNewFile * nnoremap [f :sp $BIN/QuickFileList<CR>/USEFUL/+2<CR>
au BufEnter,BufNewFile svn-commit* nnoremap [f :call Artifacts()<CR>

"-------------------------------------------------------------------------------
" QUIT CURRENT BUFFER: [q
"  Immediately exit the current buffer without saving it.
"-------------------------------------------------------------------------------
nnoremap [q :bd!<CR>

"-------------------------------------------------------------------------------
" SUBSTITUTE SHORTHAND:
"  Just a shorthand for starting the substitute command on the whole file
"-------------------------------------------------------------------------------
nnoremap S yiw:%s/\<<C-R>"\>/
vnoremap S :s/

"-------------------------------------------------------------------------------
" FORMAT DOCUMENT:
"  Replace tabs with 3 spaces & remove trailing spaces. Must insert
"  control character to find original line because can't use marks because
"  'expand' erases them.
"-------------------------------------------------------------------------------
noremap ,f :call Format()<CR>
";au BufEnter *.html* noremap ,f :call HtmlFormat()<CR>

"-------------------------------------------------------------------------------
" LIST CURRENT FILE LIST AND PROMPT FOR JUMP: [l
"-------------------------------------------------------------------------------
"noremap [l :ls<CR>:b
"noremap [L :ls<CR>:sb
noremap [l :CtrlPBuffer<CR>

"-------------------------------------------------------------------------------
" Replace the currently selected visual area with whatever you just yanked.
"-------------------------------------------------------------------------------
vnoremap p <Esc>:let current_reg = @"<CR>gvdi<C-R>=current_reg<CR><Esc>

"-------------------------------------------------------------------------------
" Scroll top and bottom windows simultaneously
"-------------------------------------------------------------------------------
"nnoremap ?? <C-E><C-W><C-W><C-E><C-W><C-W>  " Ctrl-Down
"nnoremap ?? <C-Y><C-W><C-W><C-Y><C-W><C-W>  " Ctrl-Up

"-------------------------------------------------------------------------------
" Inserts blank line below/above current line and stays in on current line and
" in command mode.
"-------------------------------------------------------------------------------
nmap oo o<ESC>k
nmap OO O<ESC>j

"-------------------------------------------------------------------------------
" Alt+Cursor Up and Down - Goes to next/previous error
"-------------------------------------------------------------------------------
"nmap ?? :cn<CR>    " Alt+Down
"nmap ?? :cp<CR>    " Alt+Up

"===============================================================================
"                                 VIM SETTINGS
"===============================================================================
version 4.0                   " Avoid warning for wrong version
set number                    " Line numbers on all files
set shellslash
set clipboard=unnamed
set suffixes+=.clw,.hm   " Put these suffixes at the end of completion code
set wildignore+=*.aps,.*~,*.txe,*.plg,*.opt
set nowrap
set winheight=5               " minimal window height
set complete=.,w,b,u,U,i,t
set hlsearch                  " Highlight search string
set tabstop=3                 " Set tabstops every 3 characters
set shiftwidth=3              " Set shift width to 3 characters
set shiftround                " Rounds > & < to nearest shift width
set autowrite                 " Write file every time ESC is pressed
set tag+=../tags
set notagrelative             " use exact path specified in tag file (not rel.)
set backspace=2               " Allow backspacing over everything in insert mode
set textwidth=80              " Set width of text
set viminfo='20,\"50          " read/write a .viminfo file, don't store more
                              "   than 50 lines of registers
set visualbell                " Stop that infernal racket!
set expandtab                 " Expand the tabs to spaces
set ruler                     " Display the column and line numbers
set ignorecase                " Ignore case when searching
set nosmartcase               " Override ignorecase if search pattern contains
                              "   upper case letters
set autoindent                " Set autoindenting on
set smartindent               " Do smart autoindenting
set smarttab                  " Tab shiftwidth positions in front of lines
set cmdheight=1               " Command line height
set comments=fb:*,fb:-,b:\",b:#   " Set comment characteristics for any file
set formatoptions=trq         " Set comment format options for any file
set cpoptions=$BceFs          " Vim/Vi settings
set isfname=@,48-57,/,:,.,-,_,+,,,$,\\,~   " omit quote and add \,~
"set grepprg=findstr\ /R\ /N\ /S " change grep program to search in subdirs file names) 
set grepprg=c:/cygwin64/bin/grep\ -nHRs\ $*\ .\ 2>nul

fun! GrepIt(Needle, ...)
   " If we are in the NERDTree, don't replace it with Grep results, switch to
   " next window first.
   if bufname("%") == t:NERDTreeBufName
      wincmd l
   endif

   " Default look in js, mustache & json files
   let l:haystack = a:0 > 0 ? a:1 : '*.{js,mustache,json}'

   " If an include/file pattern is given, then we can't specify an exclude, else default exclude.
   let l:exclude = a:0 > 0 ? '' : ' --exclude={*.swp,*production.js*,style.css}'

   execute "silent! grep " . a:Needle . l:exclude . " --exclude-dir={dist,lib,.svn,qaTest} --include=" . l:haystack
   copen
endfun
command! -nargs=+ Grep call GrepIt(<f-args>)
nnoremap gr :let @/=expand("<cword>")<CR>:Grep <cword><CR>

" Assumes that there's a list on the clipboard to parse!! Run getCommits.cmd to
" obtain and then copy from the outputted JSON.
fun! CodeReview(...) 
   " If we are in the NERDTree, don't replace it with Grep results, switch to
   " next window first.
   if bufname("%") == t:NERDTreeBufName
      wincmd l
   endif

   try
      if a:0 == 0
         let l:commits = substitute(strtrans(@*),'\^@\s\+','','g')
         silent execute "let l:commitList = " . l:commits
      else
         let l:commitList = a:1
      endif

      if len(l:commitList) > 0
         if has_key(l:commitList[0], "filename")
            call setqflist(l:commitList)
            copen
            cc 1
         endif
      endif
   catch
      echo "Clipboard contents are not in list format!"
   endtry
endfun

function! CodeReviewMenu()
   execute "let l:artifactList = " . readfile("/temp/commits.json")[0]

   let l:choices = []

   let l:ndx = 1
   for artf in artifactList
      call add(l:choices, l:ndx . artf.story)
      let l:ndx = l:ndx + 1
   endfor

   let l:choiceString = join(l:choices, "\n") 
   let l:chosen = confirm("Choose the Story to review:", l:choiceString)
   "let l:storyNdx = l:choices[l:chosen-1]

   call CodeReview(l:artifactList[l:chosen-1].paths)
endfun


"-------------------------------------------------------------------------------
" ERROR FORMAT STRINGS
"-------------------------------------------------------------------------------
"-------------------------------------------------------------------------------
"set errorformat=%f:%l:%m

"===============================================================================
"                                AUTO COMMANDS
"===============================================================================

au BufEnter *.js set formatoptions=croql cindent comments=b://,sr:/*,mnb:*,el:*/ cinoptions=>s,e0,n0,f0,{0,}0,^0,:s,=s,ps,ts,+s,(0,)0,*30
au BufEnter *.mustache,*.css,*.scss set iskeyword+=- 

"--------------------
" Batch files
"--------------------
au BufEnter *.bat set comments=b:REM,b:rem formatoptions=croq
au BufEnter *.bat set keywordprg=help

au Syntax javascript,css,scss call MyDocumentJsTags()
function! MyDocumentJsTags()
   syntax match jsDocTags containedin=.*Comment "@\(add\|alias\|body\|demo\|download\|group\|hide\|iframe\|inherits\|option\|page\|parent\|plugin\|prototype\|release\|return\|signature\|test\|typedef\|baseclass\)\>" skipwhite
	syntax match jsDocTags containedin=.*Comment "@\(abstract\|access\|alias\|arg\|argument\|augments\|author\|borrows\|callback\|class\|classdesc\|const\|constant\|constructor\|constructs\|copyright\|default\|defaultvalue\|deprecated\|desc\|description\|emits\|enum\|event\|example\|exception\|exports\|extends\|external\|file\|fileoverview\|fires\|func\|function\|global\|host\|ignore\|implements\|inheritdoc\|inner\|instance\|interface\|kind\|lends\|license\|link\|linkcode\|linkplain\|listens\|member\|memberof\|method\|mixes\|mixin\|module\|name\|namespace\|override\|overview\|param\|private\|prop\|property\|cfg\|protected\|public\|readonly\|requires\|return\|returns\|see\|since\|static\|summary\|this\|throws\|todo\|tutorial\|tutorial\|type\|typedef\|var\|variation\|version\|virtual\)\>" skipwhite
   "syntax region cssComment start=+/\*+ end=+\*/+ fold contains=@Spell,jsDocTags
   hi link jsDocTags Special
endfun

augroup vimrc_todo
   au!
   au Syntax * syn match MyTodo contained /\v<(NOTE|TODO|FUTURE|SCOTT|SERWIN|ERWIN|mah|MAH)/
         \ containedin=.*Comment.*
augroup END
hi def link MyTodo Todo

"--------------------
" Perl files
"--------------------
au FileType perl set formatoptions=croql comments=b:# cinkeys-=0#

"--------------------
" Vim Source/Macros
"--------------------
au BufEnter *.src,vim* set comments=b:\" formatoptions=croq
"au BufEnter *.src,*.vim,vim* :let sreg=@/nmap [[ ?^fun?:let @/=sreg
"au BufEnter *.src,*.vim,vim* :let sreg=@/nmap ]] /^fun/:let @/=sreg
"au BufEnter *.rc nmap [[ :let sreg=expand(@/)?^BEGIN?:let @/=sreg
"au BufEnter *.rc nmap ]] :let sreg=expand(@/)/^BEGIN/:let @/=sreg
"au BufLeave *.src,*.vim,vim* nunmap [[
"au BufLeave *.src,*.vim,vim* nunmap ]]
"au BufLeave *.rc nunmap [[
"au BufLeave *.rc nunmap ]]

"-------------------------------------------------------------------------------
" Doskey abbreviations set up as command line abbreviations - use doskey.awk to
" recreate.
"-------------------------------------------------------------------------------
so $BIN\doskey.vim

"===============================================================================
" I'm testing these...
"===============================================================================
vnoremap p "_d:norm ""p<CR>
vnoremap P "_d:norm ""P<CR>
inoremap  <ESC>bdwa

" Typo
cmap e1 e!
" Big window
"cmap bw set columns=150<CR>
" Little window
"cmap lw set columns=80<CR>

"function! HtmlFormat()
"   norm mz
"   %s/\s\+$//e " Remove trailing whitespace on all lines
"   %g/^$/d     " Delete empty lines
"   norm `z3k
"   echo "Formatting Done!"
"endf

"-------------------------------------------------------------------------------
" Function: Artifacts
" Description: Present the user with a list of possible artifacts to commit with
" for SVN. This is a Teamforge requirement.
"
" artifacts.txt is in format:
"     #.<TAB>[artfNNNNNNN]<TAB>Story# - StoryDescription
"-------------------------------------------------------------------------------
function! Artifacts()
   let artfs = readfile("c:/bin/artifacts.txt", "", 10)
   let artf = inputlist(artfs)
   if artf > 0
      " Split out the values for the line chosen into an array
      let vals = split(artfs[artf], '\t')
      let story = split(vals[2], " - ")

      " Split out and include the story/backlog # in the commit comment
      let storyNum = len(story) > 1 ? " (" . story[0] . ")" : ""
      let str = vals[1] . " Scott" . storyNum . ": "

      " Append (prepend) the commit string to the svn commit file
      let rc = append(0, str)

      " Move to the top of the file and put in Append mode
      normal gg
      normal A
   endif
endf

"command! -range=% -nargs=0 Space2Tab execute "<line1>,<line2>s/^\\( \\{".&ts."\\}\\)\\+/\\=substitute(submatch(0), ' \\{".&ts."\\}', '\\t', 'g')"

au BufNewFile,BufRead *.mxml setfiletype=mxml
au BufNewFile,BufRead *.as setfiletype=actionscript
au BufNewFile,BufRead hangout*xml set filetype=google_gadgets

"-------------------------------------------------------------------------------
" My syntax
"-------------------------------------------------------------------------------
so $VIM/vimfiles/after/syntax/mysyntax.vim

hi Comment guifg=DarkGreen ctermfg=DarkGreen

"let g:SuperTabDefaultCompletionType = 'context'
"autocmd FileType *
"   \ if &omnifunc != '' |
"   \   call SuperTabChain(&omnifunc, "<c-p>") |
"   \ endif

command! -complete=shellcmd -nargs=+ Shell call s:RunShellCommand(<q-args>)
function! s:RunShellCommand(cmdline)
  echo a:cmdline
  let expanded_cmdline = a:cmdline
  for part in split(a:cmdline, ' ')
     if part[0] =~ '\v[%#<]'
        let expanded_part = fnameescape(expand(part))
        let expanded_cmdline = substitute(expanded_cmdline, part, expanded_part, '')
     endif
  endfor
  botright new
  " turns the buffer into a "scratch" buffer
  setlocal buftype=nofile bufhidden=wipe nobuflisted noswapfile nowrap
  call setline(1, 'You entered:    ' . a:cmdline)
  call setline(2, 'Expanded Form:  ' .expanded_cmdline)
  call setline(3,substitute(getline(2),'.','=','g'))
  execute '$read !'. expanded_cmdline
  setlocal nomodifiable
endfunction

function! s:SvnIt(cmd, ...) 
   call s:RunShellCommand('svn '.a:cmd.' '.join(a:000))

   if a:cmd == "log"
      setlocal filetype=svnlog
      norm gg
   endif
endfunction

command! -complete=file -nargs=* Git call s:RunShellCommand('git '.<q-args>)
command! -complete=file -nargs=* Svn call s:SvnIt(<f-args>)
map <Leader>nf :NERDTreeFind<CR>

let g:ctrlp_working_path_mode='a'
let g:ctrlp_custom_ignore = {
\ 'dir' : '\v[\/](node_modules|dist|\.(git|svn|tmp|settings|metadata)|packages|web|web-dev)$',
\ 'file': '\v\.(exe|dll|sw[po]|bak|tgz|swp|tmp)'
\}
let g:ctrlp_mruf_exclude = "\v((.*\.(sw[po]|bak|tgz|swp|tmp))|.*\\QuickFileList|ctrlp.txt)"
let g:ctrlp_cmd="CtrlPMRU"

function! Incr()
  let a = line('.') - line("'<")
  let c = virtcol("'<")
  if a > 0
    execute 'normal! '.c.'|'.a."\<C-a>"
  endif
  normal `<
endfunction
vnoremap <C-a> :call Incr()<CR>

inoremap <C-Space> <C-x><C-o>
inoremap <C-@> <C-Space>
